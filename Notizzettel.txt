====================================================

Seminar "Clean Code"
--------------------

Guten Morgen // Moin

Peter Loos

EMail:

peter.loos@gmx.de

https://github.com/pelocpp

====================================================

Entwurfsmuster:

https://github.com/pelocpp/cpp_design_patterns

====================================================

== Visual Studio
== Github.com

====================================================

== Was sind meine Erwartungen

== No Modern C++

== C++ 98  // No std::string

== Modern C++

== Ohne STL // weil keine dyn. Speicherverwaltung

== Vererbung

== Templates

== Ausnahmebehandlung

== new // delete // eigene Speicherverwaltung

====================================================

Donnerstag:

=) Design Pattern:

   Prototype	Prototype Pattern – auch als Virtueller Konstruktor bezeichnet.
   Decorator
   Adapter
   Proxy
   Template Method
   Visitor Method
   
   RAII

=) Prinzipien (KISS, ...)

=) Unit Testing

=) Smart-Pointer (std::shared / std:weak_ptr)

=) Move-Semantik

=) Programmieren mit Datentypen

=) STL / Algorithmen / Performanz

=) Neue Utility Klassen
     std::array, std::to_array und std::span
     std::optional
     std::variant // Visitor-Konzept 
     std::any
     std::pair
     std::tuple

     std::string_view // std::string

=) Verschiedenes
   Structured Binding
   Range-based for-Loop
   Strong Types

====================================================
====================================================

Zuviel Hierarchie als zuwenig.

Was wollen wir modellieren ???

Habe ich das Instrument der Vererbung sinnvoll eingesetzt?

Hilfestellung:

== Klasse Rectangle
== Klasse ColoredRectangle

Ein ColoredRectangle ist ein Rechteck.

Beziehungen // Relationships:

is-a   // ist-ein

Vererbung: Die ist-ein Beziehung MUSS erfüllt sein.

== Klasse Point
== Klasse Line

Eine Linie ist eine Menge von Punkten

Eine Linie hat einen Start- und Endpunkt.

Eine Linie ist ein Punkt: No
Ein Punkt ist eine Linie: No

Eine Linie hat einen Start- und Endpunkt.

has-a // hat-ein Beziehung  // Mehrere

class Line 
{
    Point m_begin;
    Point m_end;
}


 Zuviel Hierarchie: Wenn wir die hat-ein Beziehung
 vorliegen haben: KEINE Vererbung.

====================================================

https://wandbox.org/

====================================================

A)

Schlüsselwort auto:

Wie komme ich von 123 zum Typ ???

In C/C++ gibt es ein Lexikon:

123 => signed int

123.45645 => double

B)

Schlüsselwort auto:


double tueWas(bool flag, int n, double m);
        
auto tueWas(bool flag, int n, double m) -> double
    
WHY ????????????????????????????

====================================================

Evolution von Programmiersprachen:

Trend:

==> C#, Java:  "Inline-Methode"

C++: Da sind wir dabei.

Neues auf bewährtes abzubilden:

Ein Lambda ist ein Aufrufbares Objekt.

"Aufrufbares Objekt"

Wann ist eine Klasse / Objekte aufrufbar.
Wenn die Klasse den operator() implementiert.


Lokale Variablen der umgebenden Funktion
sind verwendbar:

a) Kopie
b) Referenz

Lambda:  "Lambda-Methoden"

Exakt:  Ein Lambda ist ein OBJEKT !!!!!!!!!!

====================================================

Cpp Insights:

https://cppinsights.io/

Converter:

Modern C++ ==> Classic C++

====================================================

Embedded:

constexpr

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/ConstExpr/Constexpr.md

        constexpr Complex c3 = c1 + c2;
00007FF74F1C2660  movss       xmm0,dword ptr [__real@40800000 (07FF74F241D3Ch)]  
00007FF74F1C2668  movss       dword ptr [c3],xmm0  
00007FF74F1C2670  movss       xmm0,dword ptr [__real@40a00000 (07FF74F241D40h)]  
00007FF74F1C2678  movss       dword ptr [rbp+8Ch],xmm0  

        Complex c3 = c1 + c2;
00007FF652811FAF  lea         r8,[c2]  
00007FF652811FB3  lea         rdx,[c3]  
00007FF652811FBA  lea         rcx,[c1]  
00007FF652811FBE  call        ConstExprComplex::Complex::operator+ 

Ausblick:

 constexpr

std::array

std::vector 

// ====================================

Clean Code

"Hübscher / lesbarer Code"

C++ 11:

Konstanten:

123

123l

123_euro

123_kg

123_kilogramm    // int, double

0xFFAA00_color   // class Color

"123"_kg

"15:00:00"_uhrzeit

Beliebige Zeichenkette: Format

// Chrono

UDL:   User Defined Literal

Speziellen Operator:

Zieltyp operator "" _kilogramm  (params) 


================================================

new / delete

C++ 11:  Smart Pointer  // std::weak_ptr

================================================

Lebenszyklus

Rule-of-Three
Rule-of-Five
Rule-of-Zero

===============================================

std::initializer_list:  STACK (C++ 11)
std::vector:            HEAP

std::string
std::string_view        Schlanker als std::string (C++ 17)

===============================================

std::vector

std::vector<std::string> vec(10);   // Size: 10, 10 Elemente: 0
std::vector<std::string> vec{ 10 }; // Size: 1, Wert: 10

===============================================

Vorbemerkung:

== UML

== Konzeptionelle Beispiel  // clientCode

== Real-World Beispiel



Adapter:

== XML
== JSON

Pattern:  Bewährte Lösung


== Frage zu Pattern:

Wieweit muss / sollte man sich an die
Vorgaben eines Pattern halten ???

i)  Es sind Abweichungen absolut zulässig.

ii) Das Pattern sollte immer noch erkennbar sein.

Detailfrage:

Es spricht nichts dagegen, den Adaptee durch
ein Interface zu abstrahieren.

ICloneable ==> 

IEnumerator ==> 

===============================================

Proxy:

===============================================


== Adapter

== Proxy

== Template Method

== Prototype Pattern // Virtueller Konstruktor


Alle drei Pattern haben mit Methoden von Objekten zu tun.



Tetris

==> Figuren // 7

Die Figuren bewegen sich auf dieselbe Weise
-------------------------------------------

Jede Figur besitzt ihre eigenen Regeln,
um sich korrekt bewegen zu können.

===> Schablonen Methode  // Template Method

======================================================

Virtueller Konstruktor

C++ // Klassen:  Konstruktor

Konstruktor ===> aufrufen

Game Programming:

Spielebrett:  Schach

==> Figuren.

ChessFigure*  board [8][8] ;

ChessFigure:
  Pawn
  Rook
  Queen

Nächsten Zug: 

ChessFigure*  copy = board;

Kopie:   Zeiger der aktuellen Figuren kopieren ??? 

Ich will die Figuren kopiert haben:

Problem: Kenne nur Basisklassenzeiger !!!

Virtueller Konstruktor Pattern

=========================================

Decorator

== Hüllenobjekt

== Wrapper

Decorator ==> Ausschmücken  // hinzufügen

hinzufügen  ==> ableiten // spezialisieren.

Hierarchie :  Mittel der Vererbung steht nicht zur Verfügung.

== Objekt (erweitert) ==> Hülle

======================================================

Feste Klassen

==> Laufzeit etwas ergänzen

Policy-Based Design
-------------------

A) Beispiel:

new:

int* ptr = new int(123);  // 1 int

int* ptr = new int[100];  // 100 int

------------------

delete ptr;

delete[] ptr;

UB:  Undefined Behaviour


====================================================

RAII

Resources:

Socket, SqlConnection, Mutex, ....

== open, attach, connect , ...
== close, dettach, disconnect, ...  // <===

Sonderfall:  new / delete  ==> Smart Pointer


Idee:

C++  // Objekte // Konstruktoren , Destruktoren

Destruktor ==> Am Ende des Scopes // Deterministisch.

Resource:  ==> Hüllenobjekt

Konstruktor ==> open, ...
Destruktor  ==> close, ...

==================================================

Simple Tool:

Getting Started:

Catch2 Framework:

Catch2: "Header Only" (V. 2)

Catch2: Library (V. 3)

================================================

std::unique_ptr
std::shared_ptr
std::weak

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/SharedPtr/SharedPtr.md

std::unique_ptr:

Es gibt nur einen Besitzer.   // Verschieben ...

std::shared_ptr:

Es gibt nur mehrere Besitzer. 

Verwaltung // Control Bock

Clou: std::shared_ptr funktioniert nicht IMMER.

std::weak

a) Wie funktioniert dieser technisch.
b) Whyyyyyyyyyyyyyyyyyyy

Zyklische Referenzen:

Beispiel:

Observer Pattern:

Event Source  // Subject

   == Objekt mit State, der sich ändert
   == Diesen Zustand möchte ich beobachten

Event Client // Observer:

  == Interessieren sich für Änderungen des Zustands an der Event Source

 
 
 -- Event Client kennt Event Source
 -- Event Source kennt Event Clients, um diese bei Änderungen anrufen zu können.



 void connect()
 {
     EventClient client;
     EventSource source;

     source.attach (client);
 }

 // ===================================================

 Subject:


   == std::list<> m_observers;

   == std::list<Observer*> m_observers;

   == std::list< std::shared_ptr <Observer> > m_observers;

Schlecht:  

   Ein Subject sollte // DARF nicht zum OWNER // Besitzer von 
   Beobachtern werden.

   == std::list< std::weak_ptr <Observer> > m_observers;

   a) Ein Subject kontrolliert keine Lebensdauer

   b) detach .... Lösung.

   c) lock: ==> std::shared_ptr ==> update
            ==> EMTPY std::shared_ptr ==> Ergebnis ignorieren.



std::shared_ptr:  Referenz-Zähler (use_count) // 10 // 0

Wann nehme ich überhaupt einen std::shared_ptr ???

==> Wenn ich ein Besitzer sein möchte.

== Daten
== Visualisierung

==> Daten an die Visualisierung reichen ???

    std::shared_ptr ???

    std::weak_ptr ???   lock ==> nullptr
  
  
std::shared_ptr: 
std::weak_ptr: 

Clean :)

Dynamischer Speicher:

   new  // delete <===

std::shared_ptr:  1 // 2 // 3 // 2 // 1 // 0
std::weak_ptr: 

Auch hier gibt es Probleme ...

C#:  Java: Garbage Collector.

widget += listener;   // attach // detach

// widget -= listener;

Probleme des Referenzzählens:

====================================

C++ 11:   

Unnütze Kopien von Objekten

class Person
{
private:
    std:string m_name;

public:
    const std:string& getName () { return m_name; }
}

========================================

Kopieren: Bad

Verschieben: Gut :)

i)  Neuen Referenz-Typ
ii) Verschieben

C++  Referenz:

std::string s;

std::string& rs = s;


A) Technik
B) Whyyyyyyyyyyyyyyyyyyyyyyyyy

DRY ??? 

===================================

Move-Semantik:

...:  2A0    // temp. Objekt // wird freigegeben
...:  F90


...: 0E0

===================================

Clean Code:


Frage:  Move-Semantik UND Return Value

========================================

C++  // Clean Code // Aktuelle Versionen

==> Clean

==> Performanz

std::string
std::string_view ==> const char*

C-Style Array:
std::array<int, 10>
==> std::span

C++ 17 // C++ 20
----------------

== Programmieren mit Datentypen
== std::variant

===========================================


std::variant:

Kann mehrere Werte unterschiedlichen Typs
aufnehmen ... zu einem Zeitpunkt nur EINEN.

Typen müssen bekannt sein.

Excel:  Zelle // Cell


Cell: ==> num. Werte, Zeichenketten, Datum, Uhrzeit, Currency, ...

Man kann einen std::variant besuchen.

========================================

All-In

auto: Variablen-Vereinbarung
auto: Rückgabetyp

auto: Parameter // C++ 20

auto visitor = [](const auto& elem)
{
    std::println("{}", elem);
};


Templates:

template <typename T>
auto visitor = [](const T& elem)
{
    std::println("{}", elem);
};

=====================================================


std::string s; 

std::string s = "111111111111111";  // HEAP


const char* cp = "11111111111111111111111111111";

==>  std::string_view

     Mini-Hülle: a) const char*
                 b) Length

Konstanten Extra Speicher

Text-Segment // Code-Segment


Ein std::string_view ist ein NON-OWNING Objekt.



Diskussion:

substr-Methode // Teilzeichenkette:  Offset, Length

a) std::string

   ==> Neues Speicherbereich am HEAP
       Umkopieren

b) std::string_view

   ==> std::string_view:

   Ptr mit Offset addieren
   Length ist bekannt


c) std::stringstream

===========================================

std::array
std::span

C-Array:  

int numbers[100];   ==> int*   // to decay

std::array

Hülle:  Pointer + LENGTH

Fixed-Size Array

C-Array:  

int n= ???;
numbers[n] = 123; // Bereichscheck

std::array:  dto.

ABER:   Methode at

numbers.at(n) = 123;  // Bereichscheck // Exception

std::span:    NON-OWNING Container

a) Anfangsadresse
b) Länge

C-Array
std::array
std::vector